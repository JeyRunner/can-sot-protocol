#pragma once

#include "string"

static std::string genCodeTemplateHeaderContent = R"(
#pragma once

/**
 * THIS FILE IS AUTOGENERATED, DO NOT EDIT!
 * Generated by command '@@GENERATED_CMD@@'.
 */

#include <objectTree/OTNodeValueTypeDefs.h>
#include <objectTree/OTDeclares.h>
#include <objectTree/ProtocolDef.h>

namespace @@PROTOCOL_CLASS_NAME@@ {

@@ENUM_DEFS@@


/**
 * Protocol Definition for @@PROTOCOL_CLASS_NAME@@.
 * For the @@GENERATION_TARGET@@.
 */
template<typename COMC>
struct @@PROTOCOL_CLASS_NAME@@: public ProtocolDef<COMC, @@NODE_ID_TABLE_SIZE@@, @@NODES_TO_SEND_ON_INIT_TABLE_SIZE@@> {
    /// the object tree of the protocol
    struct ObjectTree: public Node {
@@OBJECT_TREE@@
    } objectTree;


    /// the index is the node id belonging to the referenced node value
    OTNodeIDsTable<@@NODE_ID_TABLE_SIZE@@> otNodeIDsTable = {
@@NODE_ID_TABLE_CONTENT@@
    };


    /**
     * meta data objects that are send to master on communication initialization.
     * These are generally read only.
     */
    ValueNodeAbstract *metaNodeValuesToSendOnInit[@@NODES_TO_SEND_ON_INIT_TABLE_SIZE@@] = {
@@NODES_TO_SEND_ON_INIT_TABLE_CONTENT@@
    };


    explicit @@PROTOCOL_CLASS_NAME@@(COMC *sotCanCommunication)
    : ProtocolDef<COMC, @@NODE_ID_TABLE_SIZE@@, @@NODES_TO_SEND_ON_INIT_TABLE_SIZE@@>(sotCanCommunication) {
        // setup all nodevalues
@@CONSTRUCTOR_SETUP_ALL_NODE_VALUES@@
    };
};


}
)";


static std::string genCodeTemplate_NodeWithChildren = R"(
struct @@NAME_TYPE@@: Node {
    @@CONTENT@@
} @@NAME@@
)";

static std::string genCodeTemplate_ValueNode = R"(ValueNode@@READ_WRITABLE@@<@@TYPE@@, @@ID@@, COMC> @@NAME@@;
)";



static std::string genCodeTemplate_IdTableEntry_noComma = R"(valueNodeAsAbstract(@@NODE_PATH@@))";
static std::string genCodeTemplate_ConstructorSetupEntry = R"(@@NODE_PATH@@.__setProtocolRef(sotCanCommunication))";





static string insertIntoTemplate(string templateStr, map<string, string> replacementValues) {
    for (auto [key, value] : replacementValues) {
        string keyFull = "@@" + key + "@@";
        bool replaced_once = false;
        auto loc = templateStr.find(keyFull);
        while (loc != std::string::npos) {
            templateStr.replace(loc, keyFull.size(), value);
            //cout << "replaced " << keyFull << endl;
            replaced_once = true;
            loc = templateStr.find(keyFull, loc);
        }
        if (!replaced_once) {
            cout << "could not replace key '" << value << "' (not found) in template: " << templateStr << endl;
            throw runtime_error("insertIntoTemplate error");
        }

    }
    // check if all replaced
    auto loc = templateStr.find("@@");
    if (loc != std::string::npos) {
        auto endLoc = templateStr.find("@@", loc+2);
        string key = templateStr.substr(loc, endLoc-loc+2);
        cout << "not all keys were replaced in template, key '"<< key <<"' was not replaced in template: " << templateStr << endl;
        throw runtime_error("insertIntoTemplate error");
    }
    return templateStr;
}