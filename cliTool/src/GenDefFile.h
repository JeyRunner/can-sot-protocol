#pragma once

#include "ftxui/dom/elements.hpp"
#include "ftxui/screen/screen.hpp"
#include "ftxui/screen/string.hpp"
#include <ryml.hpp>
#include <ryml_std.hpp>
#include <yaml-cpp/yaml.h>
#include <fstream>
#include "CliArgs.h"
#include "Util.h"
#include "YamlObjectTreeVisitor.h"

using namespace std;
using namespace ftxui;


class GenDefFile {
  public:
    CliArgs::GenProtocolSpecCommand cliArgs;

  public:

    void genDefFile(vector<string> cliCmd) {
      string argsString;
      for (auto a : cliCmd) {argsString += a + " ";}

      //printTest();
      printEl(hbox({">> "_T | bold, "will generate def file from spec file ... "_T}));
      printEl_asWindow("Parameters", vbox({
          hbox({text(L" inputSpecFileName:   "),text(cliArgs.inputSpecFileName) | bold}) | color(Color::Green),
          hbox({text(L" outputDefFileName:   "),text(cliArgs.outputDefFileName) | bold}) | color(Color::Green),
      }));

      //ryml::Tree specYaml = ryml::parse_in_place(s.c_str());
      YAML::Node spec = YAML::LoadFile(cliArgs.inputSpecFileName);
      ifstream inputSecFile(cliArgs.inputSpecFileName);

      if (!spec["object_tree"].IsSequence()) {
        cout << "object_tree key is not a sequence" << endl;
        return;
      }

      auto object_tree_predefined =  getGeneratedObjectTreeNodes();
      spec["object_tree"].push_back(object_tree_predefined["object_tree_predefined"]);
      // gen ids
      genValueNodeIds.acceptObjectTree(spec["object_tree"]);
      //genNodeValueIds(spec["object_tree"]);

      // gen remote call ids
      genRemoteCallsIds.genTable(spec["remote_calls"]);


      auto object_tree_node_idsYamlEl = YAML::Node();
      object_tree_node_idsYamlEl["object_tree_node_ids"] = YAML::Node(genValueNodeIds.object_tree_node_ids);

      auto remote_calls_idsYamlEl = YAML::Node();
      remote_calls_idsYamlEl["remote_calls_ids"] = YAML::Node(genRemoteCallsIds.ids);

      cout << endl;
      cout << "Object Tree Ids: " << endl;
      cout << YAML::Node(genValueNodeIds.object_tree_node_ids) << endl;
      cout << endl;
      cout << "Remote Calls Ids: " << endl;
      cout << YAML::Node(genRemoteCallsIds.ids) << endl;
      cout << endl;
      printEl(hbox({">> "_T | bold, text("generated ids for " + to_string(genValueNodeIds.nextNodeId) + " node values ")}));
      printEl(hbox({">> "_T | bold, text("generated ids for " + to_string(genRemoteCallsIds.nextId) + " remote calls ")}));

      if (genValueNodeIds.nextNodeId >= 255) {
          printEl(hbox({">> "_T | bold | color(Color::Red), text("number of value nodes " +
             to_string(genValueNodeIds.nextNodeId) + " is to large, max 255 allowed. ") | color(Color::Red)}));
          return;
      }

      ofstream outputDefFile(cliArgs.outputDefFileName);
      outputDefFile << "# THIS FILE IS AUTOGENERATED, DO NOT EDIT! \n";
      outputDefFile << "# File was generated from spec file: "<< cliArgs.inputSpecFileName <<" \n";
      outputDefFile << "# Generated by command '"<< argsString <<"'\n";
      outputDefFile << "\n\n";
      outputDefFile << "# autogenerated object_tree entries (these will be treated as they would be in object_tree) \n";
      outputDefFile <<  object_tree_predefined;
      outputDefFile << "\n\n";
      outputDefFile << inputSecFile.rdbuf();
      outputDefFile << "\n\n\n\n";
      outputDefFile << "# autogenerated node value id mappings \n";
      outputDefFile << object_tree_node_idsYamlEl;
      outputDefFile << "\n\n";
      outputDefFile << "# autogenerated remote_calls id mappings \n";
      outputDefFile << remote_calls_idsYamlEl << "\n";
      outputDefFile.flush();
      outputDefFile.close();
    }




    class GenValueNodeIds: public YamlObjectTreeVisitor {
    public:
        int nextNodeId = 0;
        map<int, string> object_tree_node_ids;

        void visitValueNode(ValueNode valueNode, Context context) override {
            cout << "## " << context.nodePath << "@" << valueNode.name << endl;
            object_tree_node_ids[nextNodeId] = context.nodePath + valueNode.name;
            nextNodeId += 1;
        }
    } genValueNodeIds;

    class GenRemoteCallsIds {
      public:
        int nextId = 0;
        map<int, string> ids;
        set<string> definedCalls;

        void genTable(YAML::Node remoteCallsNode) {
          if (!remoteCallsNode.IsSequence()) {
            printEl(hbox({">> Error: "_T | bold, text("remote_calls has to be a list, but its not.")}) | color(Color::Red));
            throw runtime_error("GenRemoteCallsIds");
          }
          string t;
          for (const auto &def: remoteCallsNode) {
            if (!def.IsMap()) {
              printEl(hbox({">> Error: "_T | bold, text("remote_calls entries have to be YAML objects.")}) | color(Color::Red));
              throw runtime_error("GenRemoteCallsIds");
            }
            auto name = def["name"].as<string>();
            if (definedCalls.contains(name)) {
              throw runtime_error("GenRemoteCallsIds: remote call with name "+ name+ " was defined multiple times.");
            }
            definedCalls.emplace(name);
            ids.emplace(nextId, name);
            nextId++;
          }
          if (nextId >= 0b0111'1111) {
            printEl(hbox({">> "_T | bold | color(Color::Red),
                          text("number of remote_calls " +
                          to_string(nextId) + " is to large, max 255 allowed. ") | color(Color::Red)}));
            throw runtime_error("GenRemoteCallsIds");
          }
        }
    } genRemoteCallsIds;



    YAML::Node getGeneratedObjectTreeNodes() {
        YAML::Node node;
        auto object_tree_predefined = node["object_tree_predefined"];
        object_tree_predefined["cliTool"].push_back(map<string, string>{
            {"name", "version"},
            {"default", "0"},
            {"type", "uint8"},
            {"access", "r"}
        });
        return node;
    }
};