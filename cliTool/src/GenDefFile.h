#pragma once

#include "ftxui/dom/elements.hpp"
#include "ftxui/screen/screen.hpp"
#include "ftxui/screen/string.hpp"
#include <ryml.hpp>
#include <ryml_std.hpp>
#include <yaml-cpp/yaml.h>
#include <fstream>
#include "CliArgs.h"
#include "Util.h"
#include "YamlObjectTreeVisitor.h"

using namespace std;
using namespace ftxui;


class GenDefFile {
  public:
    CliArgs::GenProtocolSpecCommand cliArgs;

  public:

    void genDefFile() {
      //printTest();
      printEl(hbox({">> "_T | bold, "will generate def file from spec file ... "_T}));
      printEl_asWindow("Parameters", vbox({
          hbox({text(L" inputSpecFileName:   "),text(cliArgs.inputSpecFileName) | bold}) | color(Color::Green),
          hbox({text(L" outputDefFileName:   "),text(cliArgs.outputDefFileName) | bold}) | color(Color::Green),
      }));

      //ryml::Tree specYaml = ryml::parse_in_place(s.c_str());
      YAML::Node spec = YAML::LoadFile(cliArgs.inputSpecFileName);
      ifstream inputSecFile(cliArgs.inputSpecFileName);

      if (!spec["object_tree"].IsSequence()) {
        cout << "object_tree key is not a sequence" << endl;
        return;
      }

      auto object_tree_predefined =  getGeneratedObjectTreeNodes();
      spec["object_tree"].push_back(object_tree_predefined["object_tree_predefined"]);
      // gen ids
      genValueNodeIds.acceptObjectTree(spec["object_tree"]);
      //genNodeValueIds(spec["object_tree"]);


      auto object_tree_node_idsYamlEl = YAML::Node();
      object_tree_node_idsYamlEl["object_tree_node_ids"] = YAML::Node(genValueNodeIds.object_tree_node_ids);

      cout << endl;
      cout << YAML::Node(genValueNodeIds.object_tree_node_ids) << endl;
      cout << endl;
      printEl(hbox({">> "_T | bold, text("generated ids for " + to_string(nextNodeId) + " node values ")}));

      ofstream outputDefFile(cliArgs.outputDefFileName);
      outputDefFile << "# autogenerated object_tree entries (these will be treated as they would be in object_tree) \n";
      outputDefFile <<  object_tree_predefined;
      outputDefFile << "\n\n";
      outputDefFile << inputSecFile.rdbuf();
      outputDefFile << "\n\n";
      outputDefFile << "# autogenerated node value id mappings \n";
      outputDefFile << object_tree_node_idsYamlEl;
      outputDefFile.flush();
      outputDefFile.close();
    }


    int nextNodeId = 0;
    map<int, string> object_tree_node_ids;

    void genNodeValueIds(const YAML::Node& node, string nodePath = "") {
      cout << "-- " << nodePath << endl;
      //cout << "+++++++++++++ " << node << endl;
      for (const auto &el : node) {
        //cout << endl<< endl<< el << endl;

        if (el.IsSequence()) {
          genNodeValueIds(el, nodePath + el.first.as<string>() + "." );
        }
        if (el.IsMap()) {
          string nodeName;
          YAML::Node nodeAttrs;
          if (!el["name"] and el.size() == 1) {
            // has sub-nodes
            if (el.begin()->second.IsSequence()) {
              genNodeValueIds(el.begin()->second, nodePath + el.begin()->first.as<string>() + "." );
              continue;
            }
            // is value node
            else if (el.begin()->second.IsMap()) {
              nodeName = el.begin()->first.as<string>();
              nodeAttrs = el.begin()->second;
            }
            else {
              cout << "Error: unsupported type in spec object_tree " << nodePath << endl;
            }
          }
          // is value node
          else if (el["name"]) {
            nodeName = el["name"].as<string>();
            nodeAttrs = el.as<YAML::Node>();
          }
          else {
            cout << "Error: wrong node object_tree " << nodePath << endl;
          }

          // is value Node
          genNodeValueIdsHandleNodeValue(nodeName, nodeAttrs, nodePath);
          //cout << "########## " << nodeName << endl;
        }
        else {
          cout << "Error: unsupported type in spec object_tree " << nodePath << endl;
        }
        //cout << el << endl << endl << endl;
      }
    }


    class GenValueNodeIds: public YamlObjectTreeVisitor {
    public:
        int nextNodeId = 0;
        map<int, string> object_tree_node_ids;

        void visitValueNode(ValueNode valueNode, Context context) override {
            cout << "##!! " << context.nodePath << "@" << valueNode.name << endl;
            object_tree_node_ids[nextNodeId] = context.nodePath + valueNode.name;
            nextNodeId += 1;
        }
    } genValueNodeIds;

    void genNodeValueIdsHandleNodeValue(string nodeName, YAML::Node nodeAttrs, string nodePath) {
      cout << "## " << nodePath << "@" << nodeName << endl;
      object_tree_node_ids[nextNodeId] = nodePath + nodeName;
      nextNodeId += 1;
    }



    YAML::Node getGeneratedObjectTreeNodes() {
        YAML::Node node;
        auto object_tree_predefined = node["object_tree_predefined"];
        object_tree_predefined["cliTool"].push_back(map<string, string>{
            {"name", "version"},
            {"default", "0"},
            {"type", "uint8"},
            {"access", "r"}
        });
        return node;
    }
};