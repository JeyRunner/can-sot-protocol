#pragma once

#include "ftxui/dom/elements.hpp"
#include "ftxui/screen/screen.hpp"
#include "ftxui/screen/string.hpp"
#include <ryml.hpp>
#include <ryml_std.hpp>
#include <yaml-cpp/yaml.h>
#include <fstream>
#include "CliArgs.h"
#include "Util.h"
#include "YamlObjectTreeVisitor.h"

using namespace std;
using namespace ftxui;


class GenDefFile {
  public:
    CliArgs::GenProtocolSpecCommand cliArgs;

  public:

    void genDefFile() {
      //printTest();
      printEl(hbox({">> "_T | bold, "will generate def file from spec file ... "_T}));
      printEl_asWindow("Parameters", vbox({
          hbox({text(L" inputSpecFileName:   "),text(cliArgs.inputSpecFileName) | bold}) | color(Color::Green),
          hbox({text(L" outputDefFileName:   "),text(cliArgs.outputDefFileName) | bold}) | color(Color::Green),
      }));

      //ryml::Tree specYaml = ryml::parse_in_place(s.c_str());
      YAML::Node spec = YAML::LoadFile(cliArgs.inputSpecFileName);
      ifstream inputSecFile(cliArgs.inputSpecFileName);

      if (!spec["object_tree"].IsSequence()) {
        cout << "object_tree key is not a sequence" << endl;
        return;
      }

      auto object_tree_predefined =  getGeneratedObjectTreeNodes();
      spec["object_tree"].push_back(object_tree_predefined["object_tree_predefined"]);
      // gen ids
      genValueNodeIds.acceptObjectTree(spec["object_tree"]);
      //genNodeValueIds(spec["object_tree"]);


      auto object_tree_node_idsYamlEl = YAML::Node();
      object_tree_node_idsYamlEl["object_tree_node_ids"] = YAML::Node(genValueNodeIds.object_tree_node_ids);

      cout << endl;
      cout << YAML::Node(genValueNodeIds.object_tree_node_ids) << endl;
      cout << endl;
      printEl(hbox({">> "_T | bold, text("generated ids for " + to_string(genValueNodeIds.nextNodeId) + " node values ")}));

      if (genValueNodeIds.nextNodeId >= 255) {
          printEl(hbox({">> "_T | bold | color(Color::Red), text("number of value nodes " +
             to_string(genValueNodeIds.nextNodeId) + " is to large, max 255 allowed. ") | color(Color::Red)}));
          return;
      }

      ofstream outputDefFile(cliArgs.outputDefFileName);
      outputDefFile << "# autogenerated object_tree entries (these will be treated as they would be in object_tree) \n";
      outputDefFile <<  object_tree_predefined;
      outputDefFile << "\n\n";
      outputDefFile << inputSecFile.rdbuf();
      outputDefFile << "\n\n";
      outputDefFile << "# autogenerated node value id mappings \n";
      outputDefFile << object_tree_node_idsYamlEl;
      outputDefFile.flush();
      outputDefFile.close();
    }




    class GenValueNodeIds: public YamlObjectTreeVisitor {
    public:
        int nextNodeId = 0;
        map<int, string> object_tree_node_ids;

        void visitValueNode(ValueNode valueNode, Context context) override {
            cout << "## " << context.nodePath << "@" << valueNode.name << endl;
            object_tree_node_ids[nextNodeId] = context.nodePath + valueNode.name;
            nextNodeId += 1;
        }
    } genValueNodeIds;



    YAML::Node getGeneratedObjectTreeNodes() {
        YAML::Node node;
        auto object_tree_predefined = node["object_tree_predefined"];
        object_tree_predefined["cliTool"].push_back(map<string, string>{
            {"name", "version"},
            {"default", "0"},
            {"type", "uint8"},
            {"access", "r"}
        });
        return node;
    }
};