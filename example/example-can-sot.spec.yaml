global_defs:
  enums: # global defined enums can be used as datatypes in the object tree
    - MOTOR_STATUS:
        OK: 0
        ERROR: 1
        DISABLED: 2
        CONFIGURATION_PROCESS: 3
    - MOTOR_CHANGE_STATE:
        DISABLE: 0
        ENABLE: 1
        START_CONFIGURATION_PROCESS: 2


object_tree:
  - settings: # nodes with sub-nodes do not have an own value
      - position_filter:
          - name: smoothing # name of the value (just has to be unique in the current tree branch)
            type: float32   # possible type value: uint8, ..., int8, ..., float16, ..., ENUM_NAME
            access: rw      # access rights for the master perspective,
                            #    possible values: 'r' for read, 'w' for write, 'rw' for read and write, 
                            #                     'only_rtp' when this value can only be written or read by a stream packages
  - motor1:
      - name: status
        type: MOTOR_STATUS
        access: r
        default: DISABLED
        
        # This is a tmp request value: 
        #   By default its value is NOT_SET, but when here the master write the value on the cilent it can be read out ONCE by the client
        #   After reading out the value on the client by the client it is set again to NOT_SET
        #   This can be used to execute a one time action with a parameter (like a remote function)
      - name: RequestStatusChange
        type: MOTOR_CHANGE_STATE
        access: w
        is_tmp_request_value: true 
        
      - current_values:
          - name: position
            type: float32
            access: r
          - name: velocity
            type: float32
            access: r
          - torque: # value node can be also defined this way (name inline) as alternative to (name: torque)
              type: float32
              access: r

      - target_values:
          - name: position
            type: float32
            access: r
          - name: velocity
            type: float32
            access: r

      #!doc
      - name: temperature
        type: float32
        access: r
        doc: # optional doc
          unit: 'Â°C'
          min: 1




# define all possible stream time packages, these can be also used to send events
stream_packages:
  - name: CurrentPosAndVel
    direction: client_to_master    # communication direction of the SP
    data_object_tree_entries:                # the total size of all entries has to be <= 8 bytes
      - "motor1.current_values.position"     # these must point to an entry in the object tree
      - "motor1.current_values.velocity"
    periodic_update:          # for SPs that are send from the client to the master, the master can enable automatic periodic updates
      update_frequencies:     # these are send in a frequency set by the master
        - 100Hz
        - 1kHz

  # Use transforms in this to PO to transfer 3 values (with original combined size > 8 byte)
  - name: CurrentPosVelTorque
    direction: client_to_master
    data_object_tree_entries: # the total size of all entries has to be <= 8 bytes
      - "motor1.current_values.position"     # these must point to an entry in the object tree
      - "motor1.current_values.velocity":
          transform:  # during sending this value in this SP it is transformed to an int16 value (will just need 2 byte)
            type: int16 # during sending value will be converted to this type via sendValue=(int16)original*scale_factor
            scale_factor: 0.0001 # to map the float to the int range, the original value is multiplied with the scale_factor
      - "motor1.current_values.torque":
          transform:
            type: int16
            scale_factor: 0.0001

  - name: TargetPosAndVel
    direction: master_to_client
    data_object_tree_entries:
      - "motor1.target_values.position"
      - "motor1.target_values.velocity"

  - name: MotorStatusAndTemp
    direction: client_to_master
    periodic_update: True # enable periodic updates
    data_object_tree_entries:
      - "motor1.status":
          only_when_changed: True # just send periodic SP when at least on value marked 'only_when_changed' changes
      - "motor1.temperature":
          only_when_changed:
            change_delta: 5  # this values just counts as changed when it's value changes at least 5 from the last send value
