global_defs:
  enums: # global defined enums can be used as datatypes in the object tree
    - MOTOR_STATUS:
        OK: 0
        ERROR: 1
        DISABLED: 2
        CONFIGURATION_PROCESS: 3
    - MOTOR_DIRECTION:
        NORMAL: 0
        INVERSE: 1
    - MOTOR_CHANGE_STATE:
        DISABLE: 0
        ENABLE: 1
        START_CONFIGURATION_PROCESS: 2
    - START_MOTOR_TESTING_ERROR:
        MOTOR_NOT_TURNING: 0
        ENCODER_ERROR: 1


object_tree:
  - settings: # nodes with sub-nodes do not have an own value
      - position_filter:
          - name: smoothing # name of the value (just has to be unique in the current tree branch)
            type: float32   # possible type value: uint8, ..., int8, ..., float16, ..., ENUM_NAME
            access: rw      # access rights for the master perspective,
                            #    possible values: 'r' for read, 'w' for write, 'rw' for read and write, 
                            #                     'only_rtp' when this value can only be written or read by a stream packages
  - motor1:
      - name: status
        doc: |
          The current status of the motor
        type: MOTOR_STATUS
        access: r
        default: DISABLED
        
        # This is a tmp request value: 
        #   By default its value is NOT_SET, but when here the master write the value on the cilent it can be read out ONCE by the client
        #   After reading out the value on the client by the client it is set again to NOT_SET
        #   This can be used to execute a one time action with a parameter (like a remote function)
      - name: RequestStatusChange
        type: MOTOR_CHANGE_STATE
        access: w
        is_tmp_request_value: true 
        
      - current_values:
          - name: position
            type: float32
            access: r
          - name: velocity
            type: float32
            access: r
          - torque: # value node can be also defined this way (name inline) as alternative to (name: torque)
              type: float32
              access: r

      - target_values:
          - name: position
            type: float32
            access: r
          - name: velocity
            type: float32
            access: r

      #!doc
      - name: temperature
        type: int32
        access: r
        doc: # optional doc
          unit: 'Â°C'
          min: 1




# define all possible stream time packages, these can be also used to send events
stream_packages:
  - name: CurrentPosAndVel
    direction: client_to_master    # communication direction of the SP
    data_object_tree_entries:                # the total size of all entries has to be <= 8 bytes
      - "motor1.current_values.position"     # these must point to an entry in the object tree
      - "motor1.current_values.velocity"
    periodic_update:          # for SPs that are send from the client to the master, the master can enable automatic periodic updates
      update_frequencies:     # these are send in a frequency set by the master
        - 100Hz
        - 1kHz

  # Use transforms in this to PO to transfer 3 values (with original combined size > 8 byte)
  - name: CurrentPosVelTorque
    direction: client_to_master
    data_object_tree_entries: # the total size of all entries has to be <= 8 bytes
      - "motor1.current_values.position"     # these must point to an entry in the object tree
      - "motor1.current_values.velocity":
          transform:  # during sending this value in this SP it is transformed to an int16 value (will just need 2 byte)
            type: int16 # during sending value will be converted to this type via sendValue=(int16)original*scale_factor
            scale_factor: 0.0001 # to map the float to the int range, the original value is multiplied with the scale_factor
      - "motor1.current_values.torque":
          transform:
            type: int16
            scale_factor: 0.0001

  - name: TargetPosAndVel
    direction: master_to_client
    data_object_tree_entries:
      - "motor1.target_values.position"
      - "motor1.target_values.velocity"

  - name: MotorStatusAndTemp
    direction: client_to_master
    periodic_update: True # enable periodic updates
    data_object_tree_entries:
      - "motor1.status":
          only_when_changed: True # just send periodic SP when at least on value marked 'only_when_changed' changes
      - "motor1.temperature":
          only_when_changed:
            change_delta: 5  # this values just counts as changed when it's value changes at least 5 from the last send value



# remote calls are similar to stream_packages in the sense that multiple values are transferred at once.
# but remote calls do not change values in the object tree, but just transfer temporary values.
# The receiver side can check if a remote call has been made and retrieve the passed arguments.
# Later the receiver can return values on success, or return an error code (defined as an enum).
# The caller can then react to the returned values or error.
remote_calls:
  - name: StartMotorTesting
    direction: master_to_client    # call direction of the remote call (Currently just calling from the master to the client is supported.)
    args:  # list of argument values (optional)
      - name: throttle
        type: int16
      - name: vel
        type: float32
    return_values_ok: # list of return values (optional)
      - name: motorAlignmentOffset
        type: float32
      - name: motorDirection
        type: MOTOR_DIRECTION
    return_value_error: START_MOTOR_TESTING_ERROR  # error return type (has to be an enum) (optional)

    # minimal remote call (empty args list, empty return values list, no error code)
  - name: DoTheThing
    direction: master_to_client
    #return_value_error:
    #  enum: # inline enum definition, works everywhere @todo
    #    THE_THING_RETURN_ERROR:
    #      THING_DOES_NOT_WORK: 0
    #      UNKNOWN_ERROR: 1