#pragma once


#include "communication/can/Can.h"
#include "driver_template/DriverTemplate.hpp"
#include "etl/circular_buffer.h"

#ifdef STM32F1
#include "stm32f1xx_hal_can.h"
#include <stm32f1xx_hal_cortex.h>
#endif


struct CanFrameWithData {
    uint16_t canId;
    uint8_t dataLength;
    uint8_t data[8];
};


#ifndef CAN_TX_BUFFER_LEN
#define CAN_TX_BUFFER_LEN 4
#endif
#ifndef CAN_RX_BUFFER_LEN
#define CAN_RX_BUFFER_LEN 4
#endif

/// enable interrupt for can tx ready
inline static void onCanTxReadyInterruptEnable();
/// disable interrupt for can tx ready
inline static void onCanTxReadyInterruptDisable();
/// enable interrupt for can rx ready
inline static void onCanRxInterruptEnable();
/// disable interrupt for can rx ready
inline static void onCanRxInterruptDisable();




/**
 * Driver for stm32 microcontrollers (currently supports stm32F1) using the stm32 HAL interface.
 * The size (number of packages) of the send end receive buffers can be set by defining the macros: CAN_TX_BUFFER_LEN, CAN_RX_BUFFER_LEN.
 * When no buffer size are specified, the default size for both buffers is 4 packages.
 * @note Just one instance of this class is allowed to exists at time.
 */
//template<uint16_t CAN_TX_BUFFER_LEN, uint16_t CAN_RX_BUFFER_LEN>
class Stm32HalCanInterface: public CanInterface {
  private:
    uint8_t ownDeviceId = 0xFF;
    static CAN_HandleTypeDef hcan;

    static etl::circular_buffer<CanFrameWithData, CAN_TX_BUFFER_LEN> txBuffer;
    static etl::circular_buffer<CanFrameWithData, CAN_RX_BUFFER_LEN> rxBuffer;

    static Stm32HalCanInterface *instance;

  public:
    /**
     * Note just one instance of this class can exists at time.
     * @param ownDeviceId the device id of this device
     * @param canHandle the handle for the can interface to use
     */
    Stm32HalCanInterface(uint8_t ownDeviceId, const CAN_HandleTypeDef &canHandle) : ownDeviceId(ownDeviceId) {
        hcan = canHandle; // @todo not sure if copy is ok
    }


    /**
     * Start the can interface. This has to be called before doing any communication over can.
     * Before the can handle has to be initialized, e.g. by calling MX_CAN_Init() which was generated by cubemx.
     * Also the timers used by can have to be set up in advance.
     */
    bool startCanInterface() const {
        uint16_t ownCanID = ((ownDeviceId & 0b000'0000'0111) << 5); // own 11 bit id
        uint16_t ownCanFilter = ((0b000'0000'0111) << 5); // 11 bit id filter
        //uint16_t ownCanFilter = 0; // 11 bit id filter

        // configure filter-banks
        // -> filter incoming can package by ID
        CAN_FilterTypeDef canFilter;
        canFilter.FilterActivation = CAN_FILTER_ENABLE;
        canFilter.FilterBank = 0;
        canFilter.FilterFIFOAssignment = CAN_RX_FIFO0;
        canFilter.FilterIdHigh = ownCanID<<5; // the 11 bit incoming ID to filter (first 5 bits would belong to extended ID)
        canFilter.FilterIdLow = 0;
        canFilter.FilterMaskIdHigh = ownCanFilter<<5; // the 11 bit fiter mask for the incoming ID to filter
        canFilter.FilterMaskIdLow = 0;
        canFilter.FilterMode = CAN_FILTERMODE_IDMASK;
        canFilter.FilterScale = CAN_FILTERSCALE_32BIT;
        canFilter.SlaveStartFilterBank = 0;
        HAL_StatusTypeDef s;
        s = HAL_CAN_ConfigFilter(&hcan, &canFilter);
        if (s != HAL_OK) {
            return false;
        }

        // enable can receive interrupt
        s = HAL_CAN_ActivateNotification(&hcan, CAN_IT_RX_FIFO0_MSG_PENDING | CAN_IT_RX_FIFO0_OVERRUN | CAN_IT_TX_MAILBOX_EMPTY);
        if (s != HAL_OK) {
            return false;
        }
        // start can
        HAL_CAN_MspInit(&hcan); // enable/setup all interrupts for can
        s = HAL_CAN_Start(&hcan);
        return s == HAL_OK;
    }


    static void handleTxOverflow() {
        // @todo implement: handle TxOverflow
    }

    static void handleRxOverflow() {
        // @todo implement: handle RxOverflow
    }


    /**
     * Put can frame into the send buffer.
     * @return true if was successfully
     */
    bool canSendFrame(CanFrame &frame) override {
        // try to directly send
        if (!sendTxFrame(frame)){
            // send queue is full -> put in buffer
            // protect queue from concurrent access
            onCanTxReadyInterruptDisable();

            if (txBuffer.full()) {
                handleTxOverflow();
                return false;
            }
            txBuffer.push(CanFrameWithData{
                .canId = frame.canId,
                .dataLength = frame.dataLength,
            });
            memcpy(txBuffer.back().data, frame.data, frame.dataLength);
            onCanTxReadyInterruptEnable();
        }
        return true;
    }


    /**
     * Get next can frame from the received buffer. This will also remove this frame from the received buffer.
     * @param receiveFrame the can id and data of this frame is COPIED from the values of the last received frame.
     *                      The data field has to point to an external allocated data array of size 8.
     * @return true if there was still a frame in the buffer, otherwise false when the buffer is empty
     */
    virtual bool getNextCanFrameReceived(CanFrame &receiveFrame) {
      onCanRxInterruptDisable();
      bool gotFrame = false;
      if (!rxBuffer.empty() && rxBuffer.size() > 0) {
        auto &frameFromBuffer = rxBuffer.front();
        receiveFrame.canId = frameFromBuffer.canId;
        receiveFrame.dataLength = frameFromBuffer.dataLength;
        memcpy(receiveFrame.data, frameFromBuffer.data, frameFromBuffer.dataLength);
        rxBuffer.pop();
        gotFrame = true;
      }
      onCanRxInterruptEnable();
      return gotFrame;
    }



    static bool canSendQueueFull() {
        uint32_t freeMailboxes = HAL_CAN_GetTxMailboxesFreeLevel(&hcan);
        return freeMailboxes <= 0;
    }

    /**
     * Send can frame
     * @return true if successful.
     */
    template<class T>
    static inline bool sendTxFrame(T &frame) {
        CAN_TxHeaderTypeDef  txHeader;
        txHeader.DLC = frame.dataLength;
        txHeader.ExtId = 0;
        txHeader.IDE = CAN_ID_STD;
        txHeader.RTR = CAN_RTR_DATA;
        txHeader.StdId = frame.canId; // id is 11 bits long
        txHeader.TransmitGlobalTime = DISABLE;

        uint32_t txMailbox;
        HAL_StatusTypeDef status = HAL_CAN_AddTxMessage(&hcan, &txHeader, frame.data, &txMailbox);
        return (status == HAL_OK);
    }

    /**
     * Send next frame from tx buffer.
     * If the buffer is empty do nothing.
     */
    static void sendNextTxFrameFromBuffer() {
        if (canSendQueueFull()) {
            return;
        }
        onCanTxReadyInterruptDisable();
        if (!txBuffer.empty()) {
            if (sendTxFrame(txBuffer.front())) {
                txBuffer.pop();
            }
        }
        onCanTxReadyInterruptEnable();
    }


    static void putRxFrameInBuffer(CAN_HandleTypeDef *hcan) {
        onCanRxInterruptDisable();
        if (!rxBuffer.full()) {
            rxBuffer.push(CanFrameWithData());
            auto &frame = rxBuffer.back();
            CAN_RxHeaderTypeDef  rxHeader;
            HAL_CAN_GetRxMessage(hcan, CAN_RX_FIFO0, &rxHeader, frame.data);
            frame.dataLength = rxHeader.DLC;
            frame.canId = rxHeader.StdId;
        }
        else {
            handleRxOverflow();
        }
        onCanRxInterruptEnable();
    }
};

CAN_HandleTypeDef Stm32HalCanInterface::hcan;
etl::circular_buffer<CanFrameWithData, CAN_TX_BUFFER_LEN> Stm32HalCanInterface::txBuffer;
etl::circular_buffer<CanFrameWithData, CAN_TX_BUFFER_LEN> Stm32HalCanInterface::rxBuffer;


#ifdef STM32F1
/// enable interrupt for can tx ready
inline static void onCanTxReadyInterruptEnable() {
    HAL_NVIC_EnableIRQ(USB_HP_CAN1_TX_IRQn);
}
/// disable interrupt for can tx ready
inline static void onCanTxReadyInterruptDisable() {
    HAL_NVIC_DisableIRQ(USB_HP_CAN1_TX_IRQn);
}
/// enable interrupt for can rx ready
inline static void onCanRxInterruptEnable() {
    HAL_NVIC_EnableIRQ(CAN1_RX1_IRQn);
    HAL_NVIC_EnableIRQ(USB_LP_CAN1_RX0_IRQn);
}
/// disable interrupt for can rx ready
inline static void onCanRxInterruptDisable() {
    HAL_NVIC_DisableIRQ(CAN1_RX1_IRQn);
    HAL_NVIC_DisableIRQ(USB_LP_CAN1_RX0_IRQn); // USB_LP_CAN1_RX0_IRQn
}
#endif


extern "C" {

/**
 * react when a tx mailbox is available again
 */
void HAL_CAN_TxMailbox0CompleteCallback(CAN_HandleTypeDef *hcan) {
  Stm32HalCanInterface::sendNextTxFrameFromBuffer();
}
void HAL_CAN_TxMailbox1CompleteCallback(CAN_HandleTypeDef *hcan) {
  Stm32HalCanInterface::sendNextTxFrameFromBuffer();
}
void HAL_CAN_TxMailbox2CompleteCallback(CAN_HandleTypeDef *hcan) {
  Stm32HalCanInterface::sendNextTxFrameFromBuffer();
}


/**
 * Handle that can package is received.
 */
void HAL_CAN_RxFifo0MsgPendingCallback(CAN_HandleTypeDef *hcan) {
  // disable this interrupt
  //onCanRxInterruptDisable();

  Stm32HalCanInterface::putRxFrameInBuffer(hcan);

  // re-enable this interrupt
  //onCanRxInterruptEnable();
}


/**
 * Handle can errors
 */
void HAL_CAN_ErrorCallback(CAN_HandleTypeDef *hcan) {
  // if rx overflow
  if (hcan->ErrorCode & HAL_CAN_ERROR_RX_FOV0) {
    Stm32HalCanInterface::handleRxOverflow();
  }
}

}