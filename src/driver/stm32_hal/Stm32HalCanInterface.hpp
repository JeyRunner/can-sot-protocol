#pragma once


#include "communication/can/Can.h"
#include "driver_template/DriverTemplate.hpp"
#include "etl/circular_buffer.h"

#ifdef STM32F1
#include "stm32f1xx_hal_can.h"
#include <stm32f1xx_hal_cortex.h>
#endif


struct CanFrameWithData {
    uint16_t canId;
    uint8_t dataLength;
    uint8_t data[8];
};


#ifndef CAN_TX_BUFFER_LEN
#define CAN_TX_BUFFER_LEN 10
#endif
#ifndef CAN_TX_BUFFER_RESERVED_SPACE_FOR_OVERFLOW_PACKAGES
#define CAN_TX_BUFFER_RESERVED_SPACE_FOR_OVERFLOW_PACKAGES 1
#endif
#ifndef CAN_RX_BUFFER_LEN
#define CAN_RX_BUFFER_LEN 10
#endif

/// enable interrupt for can tx ready
inline static void onCanTxReadyInterruptEnable();
/// disable interrupt for can tx ready
inline static void onCanTxReadyInterruptDisable();
/// enable interrupt for can rx ready
inline static void onCanRxInterruptEnable();
/// disable interrupt for can rx ready
inline static void onCanRxInterruptDisable();




/**
 * Driver for stm32 microcontrollers (currently supports stm32F1) using the stm32 HAL interface.
 * The size (number of packages) of the send end receive buffers can be set by defining the macros: CAN_TX_BUFFER_LEN, CAN_RX_BUFFER_LEN.
 * When no buffer size are specified, the default size for both buffers is 10 packages.
 * @note Just one instance of this class is allowed to exists at time.
 */
//template<uint16_t CAN_TX_BUFFER_LEN, uint16_t CAN_RX_BUFFER_LEN>
class Stm32HalCanInterface: public CanInterface {
  private:
    uint8_t ownDeviceId = 0xFF;
    static CAN_HandleTypeDef hcan;

    static etl::circular_buffer<CanFrameWithData, CAN_TX_BUFFER_LEN> txBuffer;
    static etl::circular_buffer<CanFrameWithData, CAN_RX_BUFFER_LEN> rxBuffer;

    static Stm32HalCanInterface *instance;

  public:
    /**
     * Note just one instance of this class can exists at time.
     * @param ownDeviceId the device id of this device
     * @param canHandle the handle for the can interface to use
     */
    Stm32HalCanInterface(uint8_t ownDeviceId, const CAN_HandleTypeDef &canHandle) : ownDeviceId(ownDeviceId) {
        hcan = canHandle; // @todo not sure if copy is ok
    }

    /**
     * Checks if tx buffer is full. This will return true when still CAN_TX_BUFFER_RESERVED_SPACE_FOR_OVERFLOW_PACKAGES elements can be placed into the buffer.
     * This reserved space is for sending overflow packages.
     */
    static bool txBufferIsFull() {
      return txBuffer.available() <= CAN_TX_BUFFER_RESERVED_SPACE_FOR_OVERFLOW_PACKAGES;
    }


    /**
     * Start the can interface. This has to be called before doing any communication over can.
     * Before the can handle has to be initialized, e.g. by calling MX_CAN_Init() which was generated by cubemx.
     * Also the timers used by can have to be set up in advance.
     */
    bool startCanInterface() const {
        uint16_t ownCanID = ((ownDeviceId & 0b000'0000'0111) << 5); // own 11 bit id
        uint16_t ownCanFilter = ((0b000'0000'0111) << 5); // 11 bit id filter
        //uint16_t ownCanFilter = 0; // 11 bit id filter

        // configure filter-banks
        // -> filter incoming can package by ID
        CAN_FilterTypeDef canFilter;
        canFilter.FilterActivation = CAN_FILTER_ENABLE;
        canFilter.FilterBank = 0;
        canFilter.FilterFIFOAssignment = CAN_RX_FIFO0;
        canFilter.FilterIdHigh = ownCanID<<5; // the 11 bit incoming ID to filter (first 5 bits would belong to extended ID)
        canFilter.FilterIdLow = 0;
        canFilter.FilterMaskIdHigh = ownCanFilter<<5; // the 11 bit fiter mask for the incoming ID to filter
        canFilter.FilterMaskIdLow = 0;
        canFilter.FilterMode = CAN_FILTERMODE_IDMASK;
        canFilter.FilterScale = CAN_FILTERSCALE_32BIT;
        canFilter.SlaveStartFilterBank = 0;
        HAL_StatusTypeDef s;
        s = HAL_CAN_ConfigFilter(&hcan, &canFilter);
        if (s != HAL_OK) {
            return false;
        }

        // enable can receive interrupt
        s = HAL_CAN_ActivateNotification(&hcan, CAN_IT_RX_FIFO0_MSG_PENDING | CAN_IT_RX_FIFO0_OVERRUN | CAN_IT_TX_MAILBOX_EMPTY);
        if (s != HAL_OK) {
            return false;
        }
        // start can
        HAL_CAN_MspInit(&hcan); // enable/setup all interrupts for can
        s = HAL_CAN_Start(&hcan);
        return s == HAL_OK;
    }


    /**
     * Put can frame into the send buffer.
     * @return true if was successfully
     */
    bool canSendFrame(CanFrame &frame, bool frameIsOverflowError=false) override {
        // try to directly send
        if (!sendTxFrame(frame)){
            // send queue is full -> put in buffer
            // protect queue from concurrent access
            onCanTxReadyInterruptDisable();

            if (txBufferIsFull()) {
              if (!frameIsOverflowError) {
                handleTxOverflow();
              }
              return false;
            }
            txBuffer.push(CanFrameWithData{
                .canId = frame.canId,
                .dataLength = frame.dataLength,
            });
            memcpy(txBuffer.back().data, frame.data, frame.dataLength);
            onCanTxReadyInterruptEnable();
        }
        else {
          // try to also send remaining frames in buffer
          trySendAllTxFramesFromBuffer();
        }
        return true;
    }


    /**
     * Get next can frame from the received buffer. This will also remove this frame from the received buffer.
     * @param receiveFrame the can id and data of this frame is COPIED from the values of the last received frame.
     *                      The data field has to point to an external allocated data array of size 8.
     * @return true if there was still a frame in the buffer, otherwise false when the buffer is empty
     */
    virtual bool getNextCanFrameReceived(CanFrame &receiveFrame) {
      onCanRxInterruptDisable();
      bool gotFrame = false;
      if (!rxBuffer.empty() && rxBuffer.size() > 0) {
        auto &frameFromBuffer = rxBuffer.front();
        receiveFrame.canId = frameFromBuffer.canId;
        receiveFrame.dataLength = frameFromBuffer.dataLength;
        memcpy(receiveFrame.data, frameFromBuffer.data, frameFromBuffer.dataLength);
        rxBuffer.pop();
        gotFrame = true;
      }
      onCanRxInterruptEnable();
      return gotFrame;
    }



    static bool canSendQueueFull() {
        uint32_t freeMailboxes = HAL_CAN_GetTxMailboxesFreeLevel(&hcan);
        return freeMailboxes <= 0;
    }

    /**
     * Send can frame directly, when currently the hardware send queue is full return false.
     * @return true if successful.
     */
    template<class T>
    static inline bool sendTxFrame(T &frame) {
        if (canSendQueueFull()) {
          return false;
        }
        CAN_TxHeaderTypeDef  txHeader;
        txHeader.DLC = frame.dataLength;
        txHeader.ExtId = 0;
        txHeader.IDE = CAN_ID_STD;
        txHeader.RTR = CAN_RTR_DATA;
        txHeader.StdId = frame.canId; // id is 11 bits long
        txHeader.TransmitGlobalTime = DISABLE;

        uint32_t txMailbox;
        HAL_StatusTypeDef status = HAL_CAN_AddTxMessage(&hcan, &txHeader, frame.data, &txMailbox);
        return (status == HAL_OK);
    }

    /**
     * Send next frame from tx buffer.
     * If the buffer is empty do nothing.
     */
    static void sendNextTxFrameFromBuffer() {
        if (canSendQueueFull()) {
            return;
        }
        onCanTxReadyInterruptDisable();
        if (!txBuffer.empty()) {
            if (sendTxFrame(txBuffer.front())) {
                txBuffer.pop();
            }
        }
        onCanTxReadyInterruptEnable();
    }


    /// try to send all frames from rx buffer, if something fails abort
    static void trySendAllTxFramesFromBuffer() {
      onCanTxReadyInterruptDisable();
      while (!canSendQueueFull() && !txBuffer.empty()) {
        if (sendTxFrame(txBuffer.front())) {
          txBuffer.pop();
        }
        else {
          break;
        }
      }
      onCanTxReadyInterruptEnable();
    }


    static void putRxFrameInBuffer(CAN_HandleTypeDef *hcan) {
        onCanRxInterruptDisable();
        if (!rxBuffer.full()) {
            rxBuffer.push(CanFrameWithData());
            auto &frame = rxBuffer.back();
            CAN_RxHeaderTypeDef  rxHeader;
            HAL_CAN_GetRxMessage(hcan, CAN_RX_FIFO0, &rxHeader, frame.data);
            frame.dataLength = rxHeader.DLC;
            frame.canId = rxHeader.StdId;
        }
        else {
            // read it anyway so that the rx queue of the hardware does not overflow
            CAN_RxHeaderTypeDef  rxHeader;
            uint8_t data[8];
            HAL_CAN_GetRxMessage(hcan, CAN_RX_FIFO0, &rxHeader, data);
            handleRxOverflow();
        }
        onCanRxInterruptEnable();
    }

  private:
    static inline uint32_t LL_SYSTICK_IsActiveCounterFlag()
    {
      return ((SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk) == (SysTick_CTRL_COUNTFLAG_Msk));
    }


  public:
    /// get number of packages in rx buffer
    unsigned int getRxBufferNumPackages() {
      return rxBuffer.size();
    }
    /// get number of packages in tx buffer
    unsigned int getTxBufferNumPackages() {
      return txBuffer.size();
    }



    /// get current relative time in microseconds
    uint32_t getCurrentMicros()
    {
      /* Ensure COUNTFLAG is reset by reading SysTick control and status register */
      LL_SYSTICK_IsActiveCounterFlag();
      uint32_t m = HAL_GetTick();
      const uint32_t tms = SysTick->LOAD + 1;
      __IO uint32_t u = tms - SysTick->VAL;
      if (LL_SYSTICK_IsActiveCounterFlag()) {
        m = HAL_GetTick();
        u = tms - SysTick->VAL;
      }
      return (m * 1000 + (u * 1000) / tms);
    }

};

CAN_HandleTypeDef Stm32HalCanInterface::hcan;
etl::circular_buffer<CanFrameWithData, CAN_TX_BUFFER_LEN> Stm32HalCanInterface::txBuffer;
etl::circular_buffer<CanFrameWithData, CAN_TX_BUFFER_LEN> Stm32HalCanInterface::rxBuffer;


#ifdef STM32F1
/// enable interrupt for can tx ready
inline static void onCanTxReadyInterruptEnable() {
    HAL_NVIC_EnableIRQ(USB_HP_CAN1_TX_IRQn);
}
/// disable interrupt for can tx ready
inline static void onCanTxReadyInterruptDisable() {
    HAL_NVIC_DisableIRQ(USB_HP_CAN1_TX_IRQn);
}
/// enable interrupt for can rx ready
inline static void onCanRxInterruptEnable() {
    HAL_NVIC_EnableIRQ(CAN1_RX1_IRQn);
    HAL_NVIC_EnableIRQ(USB_LP_CAN1_RX0_IRQn);
}
/// disable interrupt for can rx ready
inline static void onCanRxInterruptDisable() {
    HAL_NVIC_DisableIRQ(CAN1_RX1_IRQn);
    HAL_NVIC_DisableIRQ(USB_LP_CAN1_RX0_IRQn); // USB_LP_CAN1_RX0_IRQn
}
#endif


extern "C" {

/**
 * react when a tx mailbox is available again
 */
void HAL_CAN_TxMailbox0CompleteCallback(CAN_HandleTypeDef *hcan) {
  Stm32HalCanInterface::sendNextTxFrameFromBuffer();
}
void HAL_CAN_TxMailbox1CompleteCallback(CAN_HandleTypeDef *hcan) {
  Stm32HalCanInterface::sendNextTxFrameFromBuffer();
}
void HAL_CAN_TxMailbox2CompleteCallback(CAN_HandleTypeDef *hcan) {
  Stm32HalCanInterface::sendNextTxFrameFromBuffer();
}


/**
 * Handle that can package is received.
 */
void HAL_CAN_RxFifo0MsgPendingCallback(CAN_HandleTypeDef *hcan) {
  // disable this interrupt
  //onCanRxInterruptDisable();

  Stm32HalCanInterface::putRxFrameInBuffer(hcan);

  // re-enable this interrupt
  //onCanRxInterruptEnable();
}


/**
 * Handle can errors
 */
void HAL_CAN_ErrorCallback(CAN_HandleTypeDef *hcan) {
  // if rx overflow
  if (hcan->ErrorCode & HAL_CAN_ERROR_RX_FOV0) {
    Stm32HalCanInterface::handleRxOverflow();
  }
}

}